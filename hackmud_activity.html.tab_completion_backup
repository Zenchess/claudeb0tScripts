<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>hackmud Terminal - Live View</title>
    <style>
        @font-face {
            font-family: 'WhiteRabbit';
            src: url('WhiteRabbitHackmudExtended.ttf') format('truetype');
        }

        :root {
            --bg-dark: #0a0a0a;
            --bg-panel: #111;
            --green: #1EFF00;
            --orange: #FF8000;
            --cyan: #00FFFF;
            --magenta: #FF00EC;
            --blue: #0070DD;
            --gray: #9B9B9B;
            --dark-gray: #3F3F3F;
            --red: #FF4444;
            --yellow: #FBC803;
            --white: #CCC;
            --purple: #B035EE;
            --default: #83B0F2;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg-dark);
            color: var(--default);
            font-family: 'WhiteRabbit', monospace;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* CCTV Flicker Animation */
        @keyframes flicker {
            0% { opacity: 0.97; }
            5% { opacity: 0.95; }
            10% { opacity: 0.98; }
            15% { opacity: 0.96; }
            20% { opacity: 0.99; }
            25% { opacity: 0.94; }
            30% { opacity: 0.98; }
            35% { opacity: 0.96; }
            40% { opacity: 0.99; }
            45% { opacity: 0.95; }
            50% { opacity: 0.97; }
            55% { opacity: 0.98; }
            60% { opacity: 0.96; }
            65% { opacity: 0.99; }
            70% { opacity: 0.95; }
            75% { opacity: 0.98; }
            80% { opacity: 0.97; }
            85% { opacity: 0.96; }
            90% { opacity: 0.99; }
            95% { opacity: 0.95; }
            100% { opacity: 0.97; }
        }

        .header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--dark-gray);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: var(--orange);
            font-size: 1.5em;
            text-shadow: 0 0 10px rgba(255, 128, 0, 0.5);
        }

        .status {
            color: var(--gray);
            font-size: 0.9em;
        }

        .status.live {
            color: var(--green);
        }

        .container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 10px;
            padding: 10px;
            height: calc(100vh - 60px);
            overflow: hidden;
        }

        .panel {
            background: var(--bg-panel);
            border: 1px solid var(--dark-gray);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            background: #1a1a1a;
            padding: 10px;
            border-bottom: 1px solid var(--dark-gray);
            font-weight: bold;
            color: var(--cyan);
            font-size: 0.9em;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-size: 14px;
            line-height: 1.3;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* CCTV Effects - applied to entire panel */
        .panel {
            position: relative;
        }

        /* CCTV Scanline Effect - covers entire visible panel */
        .panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%,
                rgba(0, 0, 0, 0.35) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 999;
            opacity: 0.65;
        }

        /* Brightness filter on panel content only */
        .panel-content {
            filter: brightness(1.08) contrast(1.2) saturate(1.25);
        }

        .right-side {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            overflow: hidden;
        }

        .right-panel {
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }

        .badge-panel {
            flex: 0 0 auto !important;
            max-height: fit-content;
        }

        .breach-panel {
            flex: 0 0 auto !important;
            max-height: fit-content;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--dark-gray);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Hackmud color classes */
        .c-green { color: var(--green); }
        .c-orange { color: var(--orange); }
        .c-cyan { color: var(--cyan); }
        .c-magenta { color: var(--magenta); }
        .c-blue { color: var(--blue); }
        .c-gray { color: var(--gray); }
        .c-dark-gray { color: var(--dark-gray); }
        .c-red { color: var(--red); }
        .c-yellow { color: var(--yellow); }
        .c-white { color: var(--white); }
        .c-purple { color: var(--purple); }
        .c-default { color: var(--default); }

        .error {
            color: var(--red);
            text-align: center;
            padding: 20px;
        }

        .loading {
            color: var(--gray);
            text-align: center;
            padding: 20px;
        }

        /* Command Bar */
        .command-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-panel);
            border-top: 2px solid var(--orange);
            padding: 10px 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 1000;
        }

        .command-bar input {
            flex: 1;
            background: var(--bg-dark);
            border: 1px solid var(--dark-gray);
            color: var(--green);
            padding: 8px 12px;
            font-family: 'WhiteRabbit', monospace;
            font-size: 14px;
        }

        .command-bar input:focus {
            outline: none;
            border-color: var(--green);
        }

        .command-bar input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .command-bar button {
            background: var(--bg-dark);
            border: 1px solid var(--green);
            color: var(--green);
            padding: 8px 16px;
            cursor: pointer;
            font-family: 'WhiteRabbit', monospace;
            font-size: 14px;
            transition: all 0.2s;
        }

        .command-bar button:hover:not(:disabled) {
            background: var(--green);
            color: var(--bg-dark);
        }

        .command-bar button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: var(--dark-gray);
            color: var(--dark-gray);
        }

        /* Auth Status */
        .auth-status {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.85em;
        }

        .auth-button {
            background: var(--bg-dark);
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 6px 12px;
            cursor: pointer;
            font-family: 'WhiteRabbit', monospace;
            font-size: 0.85em;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
        }

        .auth-button:hover {
            background: var(--cyan);
            color: var(--bg-dark);
        }

        .auth-button.logout {
            border-color: var(--red);
            color: var(--red);
        }

        .auth-button.logout:hover {
            background: var(--red);
            color: var(--bg-dark);
        }

        .user-info {
            color: var(--cyan);
        }

        .session-code {
            background: var(--bg-dark);
            border: 1px solid var(--green);
            color: var(--green);
            padding: 8px 12px;
            font-family: 'WhiteRabbit', monospace;
            font-size: 1.2em;
            letter-spacing: 2px;
            display: inline-block;
            margin-left: 10px;
        }

        .session-info {
            color: var(--green);
            font-size: 0.85em;
            margin-left: 10px;
        }

        .auth-button.session {
            border-color: var(--green);
            color: var(--green);
        }

        .auth-button.session:hover {
            background: var(--green);
            color: var(--bg-dark);
        }

        .container {
            padding-bottom: 60px; /* Space for command bar */
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>&gt;&gt;hackmud.terminal{live:true}</h1>
        <div class="auth-status" id="authStatus">
            <div class="status" id="status">Connecting...</div>
            <a href="/login" class="auth-button" id="loginButton">Login with Discord</a>
            <button class="auth-button session" id="sessionButton" onclick="startSessionAuth()">Session Auth</button>
            <span class="session-info" id="sessionInfo"></span>
        </div>
    </div>

    <div class="container">
        <!-- Shell/Terminal -->
        <div class="panel">
            <div class="panel-header">TERMINAL / SHELL</div>
            <div class="panel-content" id="shell-content">
                <div class="loading">Loading terminal...</div>
            </div>
        </div>

        <!-- Right Side Panels -->
        <div class="right-side">
            <!-- Badge -->
            <div class="panel right-panel badge-panel">
                <div class="panel-header">BADGE</div>
                <div class="panel-content" id="badge-content">
                    <div class="loading">Loading badge...</div>
                </div>
            </div>

            <!-- Breach -->
            <div class="panel right-panel breach-panel">
                <div class="panel-header">BREACH STATUS</div>
                <div class="panel-content" id="breach-content">
                    <div class="loading">Loading breach...</div>
                </div>
            </div>

            <!-- Chat -->
            <div class="panel right-panel">
                <div class="panel-header">CHAT</div>
                <div class="panel-content" id="chat-content">
                    <div class="loading">Loading chat...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = '/api/terminal';
        let updateInterval;

        // Color mapping from Unity colors to our CSS variables
        const colorMap = {
            '#1EFF00': 'c-green',
            '#FF8000': 'c-orange',
            '#00FFFF': 'c-cyan',
            '#FF00EC': 'c-magenta',
            '#0070DD': 'c-blue',
            '#9B9B9B': 'c-gray',
            '#3F3F3F': 'c-dark-gray',
            '#FF4444': 'c-red',
            '#FBC803': 'c-yellow',
            '#CCCCCC': 'c-white',
            '#B035EE': 'c-purple',
            '#83B0F2': 'c-default',
            '#FFFFFF': 'c-white'
        };

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function convertUnityColorsToHTML(text) {
            // Convert Unity <color=#RRGGBB> or <color=#RRGGBBAA> tags to inline styled spans
            // Process nested tags by repeatedly replacing innermost tags first

            let prevText;
            let iterations = 0;
            const maxIterations = 30;

            do {
                prevText = text;
                // Match color tags whose content doesn't contain other color tags
                text = text.replace(/<color=(#[0-9A-Fa-f]{6,8})>((?:(?!<color).)*?)<\/color>/gs, (match, color, content) => {
                    // Use the full color including alpha if present (browsers support it)
                    return `<span style="color:${color};">${content}</span>`;
                });

                iterations++;
            } while (prevText !== text && iterations < maxIterations);

            return text;
        }

        async function fetchTerminalData() {
            try {
                const response = await fetch(API_URL);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                // Update status
                document.getElementById('status').textContent = 'LIVE';
                document.getElementById('status').classList.add('live');

                // Update shell
                if (data.shell) {
                    const html = convertUnityColorsToHTML(data.shell);
                    const shellContent = document.getElementById('shell-content');
                    shellContent.innerHTML = html;
                    // Auto-scroll to bottom
                    shellContent.scrollTop = shellContent.scrollHeight;
                }

                // Update badge
                if (data.badge) {
                    const html = convertUnityColorsToHTML(data.badge);
                    document.getElementById('badge-content').innerHTML = html;
                }

                // Update breach
                if (data.breach) {
                    const html = convertUnityColorsToHTML(data.breach);
                    document.getElementById('breach-content').innerHTML = html;
                }

                // Update chat
                if (data.chat) {
                    const html = convertUnityColorsToHTML(data.chat);
                    const chatContent = document.getElementById('chat-content');
                    chatContent.innerHTML = html;
                    // Auto-scroll to bottom
                    chatContent.scrollTop = chatContent.scrollHeight;
                }

            } catch (error) {
                console.error('Error fetching terminal data:', error);
                document.getElementById('status').textContent = 'ERROR: ' + error.message;
                document.getElementById('status').classList.remove('live');

                // Show error in panels
                const errorMsg = `<div class="error">Failed to fetch data: ${error.message}</div>`;
                document.getElementById('shell-content').innerHTML = errorMsg;
                document.getElementById('badge-content').innerHTML = errorMsg;
                document.getElementById('breach-content').innerHTML = errorMsg;
                document.getElementById('chat-content').innerHTML = errorMsg;
            }
        }

        // Check user authentication status
        async function checkAuthStatus() {
            try {
                const response = await fetch('/api/user', {
                    credentials: 'include'
                });
                const data = await response.json();

                const authStatus = document.getElementById('authStatus');
                const loginButton = document.getElementById('loginButton');
                const commandInput = document.getElementById('commandInput');
                const sendButton = document.getElementById('sendCommand');

                if (data.authenticated && data.authorized) {
                    // User is logged in and authorized
                    loginButton.textContent = `${data.username} | Logout`;
                    loginButton.href = '/logout';
                    loginButton.classList.add('logout');

                    // Enable command input
                    commandInput.disabled = false;
                    commandInput.placeholder = '> Enter hackmud command...';
                    sendButton.disabled = false;
                } else if (data.authenticated && !data.authorized) {
                    // User is logged in but not authorized
                    loginButton.textContent = 'Unauthorized | Logout';
                    loginButton.href = '/logout';
                    loginButton.classList.add('logout');
                } else {
                    // User is not logged in
                    loginButton.textContent = 'Login with Discord';
                    loginButton.href = '/login';
                    loginButton.classList.remove('logout');

                    // Disable command input
                    commandInput.disabled = true;
                    commandInput.placeholder = '> Login to send commands...';
                    sendButton.disabled = true;
                }
            } catch (error) {
                console.error('Auth check failed:', error);
            }
        }

        // Send command to hackmud
        async function sendCommand() {
            const commandInput = document.getElementById('commandInput');
            const command = commandInput.value.trim();

            if (!command) return;

            try {
                const sendButton = document.getElementById('sendCommand');
                sendButton.disabled = true;
                sendButton.textContent = 'Sending...';

                const response = await fetch('/api/command', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({ command })
                });

                const data = await response.json();

                if (data.success) {
                    commandInput.value = '';
                    // Terminal will update automatically on next fetch
                } else {
                    alert('Command failed: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Command execution failed: ' + error.message);
            } finally {
                const sendButton = document.getElementById('sendCommand');
                sendButton.disabled = false;
                sendButton.textContent = 'Send';
            }
        }

        // Tab completion for hackmud commands
        let commandTemplates = {};

        // Load autocomplete data from hackmud settings
        async function loadAutocomplete() {
            try {
                const response = await fetch('/api/autocomplete');
                if (!response.ok) return;

                const data = await response.json();
                if (!data.userAutos) return;

                // Convert hackmud autocomplete format to command templates
                for (const [namespace, commands] of Object.entries(data.userAutos)) {
                    for (const [cmd, args] of Object.entries(commands)) {
                        const fullCmd = `${namespace}.${cmd}`;

                        if (args === null) {
                            // Simple command with no arguments
                            commandTemplates[fullCmd] = fullCmd;
                        } else {
                            // Command with arguments - build template
                            const argParts = [];
                            for (const [key, val] of Object.entries(args)) {
                                if (typeof val === 'string') {
                                    // Has default value, use it
                                    argParts.push(`${key}:█`);
                                } else {
                                    argParts.push(`${key}:█`);
                                }
                            }

                            commandTemplates[fullCmd] = `${fullCmd}{${argParts.join(',')}}`;
                        }
                    }
                }

                console.log(`Loaded ${Object.keys(commandTemplates).length} autocomplete templates`);
            } catch (error) {
                console.error('Failed to load autocomplete:', error);
            }
        }

        // Load autocomplete on page load
        loadAutocomplete();

        let tabCompletionState = {
            active: false,
            template: '',
            positions: [],
            currentIndex: 0
        };

        function handleTabCompletion(event) {
            const input = document.getElementById('commandInput');
            const currentValue = input.value;
            const cursorPos = input.selectionStart;

            // Check if we're in the middle of tab completion
            if (tabCompletionState.active) {
                // Move to next argument position
                tabCompletionState.currentIndex++;
                if (tabCompletionState.currentIndex < tabCompletionState.positions.length) {
                    const pos = tabCompletionState.positions[tabCompletionState.currentIndex];
                    input.setSelectionRange(pos, pos);
                } else {
                    // End of arguments, reset
                    tabCompletionState.active = false;
                    input.setSelectionRange(input.value.length, input.value.length);
                }
                return;
            }

            // Find matching command template
            for (const [cmd, template] of Object.entries(commandTemplates)) {
                if (currentValue.startsWith(cmd)) {
                    // Already matched, don't re-complete
                    if (currentValue.includes('{')) continue;

                    // Insert template
                    const completed = template.replace(/█/g, '');
                    input.value = completed;

                    // Find argument positions (█ markers in original template)
                    const positions = [];
                    let searchPos = 0;
                    const templateCopy = template;
                    while (true) {
                        const idx = templateCopy.indexOf('█', searchPos);
                        if (idx === -1) break;
                        positions.push(idx - positions.length); // Adjust for removed markers
                        searchPos = idx + 1;
                    }

                    if (positions.length > 0) {
                        tabCompletionState = {
                            active: true,
                            template: template,
                            positions: positions,
                            currentIndex: 0
                        };
                        input.setSelectionRange(positions[0], positions[0]);
                    }
                    return;
                }

                // Partial match - complete the command name
                if (cmd.startsWith(currentValue) && currentValue.length > 0) {
                    input.value = cmd;
                    input.setSelectionRange(cmd.length, cmd.length);
                    return;
                }
            }
        }

        // Session-based authentication
        let sessionPollInterval = null;

        async function startSessionAuth() {
            try {
                // Create a new session
                const response = await fetch('/api/session/create', {
                    method: 'POST',
                    credentials: 'include'
                });
                const data = await response.json();

                if (data.session_code) {
                    // Display session code
                    document.getElementById('sessionInfo').innerHTML =
                        `Code: <span class="session-code">${data.session_code}</span> - Type <code>!auth ${data.session_code}</code> in Discord`;

                    // Hide session button
                    document.getElementById('sessionButton').style.display = 'none';

                    // Start polling for auth
                    sessionPollInterval = setInterval(checkSessionStatus, 2000);
                }
            } catch (error) {
                console.error('Failed to create session:', error);
                alert('Failed to create session: ' + error.message);
            }
        }

        async function checkSessionStatus() {
            try {
                const response = await fetch('/api/session/status', {
                    credentials: 'include'
                });
                const data = await response.json();

                if (data.authenticated) {
                    // Session authenticated!
                    clearInterval(sessionPollInterval);
                    document.getElementById('sessionInfo').innerHTML = '';
                    document.getElementById('sessionButton').style.display = 'inline-block';

                    // Update auth status
                    checkAuthStatus();
                }
            } catch (error) {
                console.error('Failed to check session status:', error);
            }
        }

        // Initial fetch
        fetchTerminalData();
        checkAuthStatus();

        // Update every 2 seconds
        updateInterval = setInterval(fetchTerminalData, 2000);
        setInterval(checkAuthStatus, 10000); // Check auth every 10 seconds
    </script>

    <!-- Command Bar -->
    <div class="command-bar">
        <input
            type="text"
            id="commandInput"
            placeholder="> Login to send commands..."
            disabled
            onkeydown="handleCommandKeypress(event)"
        />
        <button id="sendCommand" onclick="sendCommand()" disabled>Send</button>
    </div>
</body>
</html>
